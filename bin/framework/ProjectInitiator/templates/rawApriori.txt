

const { FPGrowth } = require('node-fpgrowth');


let associationBoostedList = [];


/**
 * Generates a list of "boosted" items based on association rule mining using the FP-Growth algorithm.
 *
 * @async
 * @function generateBoostList
 * @param {Array<Object>} data - Array of objects representing rows from the database.
 * @param {number} support - Minimum support threshold (between 0 and 1).
 * @param {number} confidence - Minimum confidence threshold (between 0 and 1).
 * @param {Array<string>} itemFields - Array of column names to treat as items within a transaction.
 * @param {string} targetGroupField - The field used to group data into transactions (e.g., a timestamp or ID).
 * @returns {Promise<Array<string>>} - Promise resolving to an array of unique items that participate in any frequent itemset or association rule.
 * @throws {Error} If required parameters are missing or invalid.
 */

const generateBoostList = async (data, support, confidence, itemFields, targetGroupField) => {

    if (!data || !Array.isArray(data) || data.length === 0 || support == null || confidence == null || !itemFields || itemFields.length === 0) {
        throw new Error("Missing or invalid required parameters for association rule mining.");
    }

    // STEP 1: Group data by RecordedTimeStamp to form true transactions
    const transactionsMap = data.reduce((acc, row) => {
        const groupKey = row[targetGroupField] instanceof Date
            ? row[targetGroupField].toISOString()
            : row[targetGroupField];

        if (!acc[groupKey]) acc[groupKey] = new Set();

        itemFields.forEach(field => {
            if (row[field]) acc[groupKey].add(row[field]);
        });

        return acc;
    }, []);

    // Convert the map of Sets into an array of arrays (transactions)
    const transactions = Object.values(transactionsMap).map(s => Array.from(s));

    if (transactions.length === 0) {
        console.log("No transactions formed after grouping. Returning empty list.");
        return [];
    }

    // STEP 2: Run FP-Growth
    const fpgrowth = new FPGrowth(support, confidence);
    let itemsets = [];
    try {
        itemsets = await fpgrowth.exec(transactions);
    } catch (error) {
        console.error("Error during FP-Growth execution:", error);
    }

    // STEP 3: Extract relevant items from the discovered rules/frequent itemsets
    // This part depends on what you mean by "boosted list".
    // If you want all items that participate in *any* frequent itemset or rule:
    const boostSet = new Set();
    itemsets.forEach(rule => {
        // node-fpgrowth returns objects like { items: [...], support: X } for frequent itemsets
        // and { antecedent: [...], consequent: [...], support: X, confidence: Y, lift: Z } for rules.
        // We'll collect items from both.
        if (rule.items) { // This is a frequent itemset
            rule.items.forEach(item => boostSet.add(item));
        }
        if (rule.antecedent) { // This is an association rule
            rule.antecedent.forEach(item => boostSet.add(item));
        }
        if (rule.consequent) { // This is an association rule
            rule.consequent.forEach(item => boostSet.add(item));
        }
    });

    associationBoostedList = Array.from(boostSet);
    return associationBoostedList;
};

/**
 * Retrieves the current list of boosted items generated by the last call to generateBoostList.
 *
 * @function getBoosList
 * @returns {Array<string>} - Array of unique boosted items.
 */

const getBoostList = () => associationBoostedList;

module.exports = {
    generateBoostList,
    getBoostList
};